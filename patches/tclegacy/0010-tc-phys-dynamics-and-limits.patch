From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
Subject: [PATCH 10/10] tc: per-entity dynamics + engine hookup + performance limits (MVP)

- Overlay: config/limits (g_physics_limits.{h,c}) and simple per-entity dynamics
  (gravity, friction, bounce, sleep), plus TC_Physics_Step().
- Engine: call TC_Physics_Step() each frame and push new origins into g_entities,
  link them for replication.
- Cvars: g_tcphys_enable, g_tcphys_maxActive, g_tcphys_budgetMS, g_tcphys_tickHz,
  g_tcphys_sleepVel, g_tcphys_sleepTime, g_tcphys_gravity, g_tcphys_bounce,
  g_tcphys_friction, g_tcphys_lodFar, tc_phys_draw (debug).

---
 src/game/g_main.c  | 35 +++++++++++++++++++++++++++++++++++
 src/game/g_local.h | 14 ++++++++++++++
 2 files changed, 49 insertions(+ )

--- a/src/game/g_local.h
+++ b/src/game/g_local.h
@@
+typedef struct TCPhysConfig_s TCPhysConfig_t;
+void TC_Phys_SetConfig(const TCPhysConfig_t* cfg);
+void TC_Physics_Step(int msec, const float playerOrigin[3]);
+int  TC_EntPhysicsIsRegistered(int entNum);
+int  TC_EntPhysicsGetState(int entNum, void* out); /* opaque */

--- a/src/game/g_main.c
+++ b/src/game/g_main.c
@@
+#ifdef TC_PHYSICS
+static void TC_ReadCvarsAndStep( int msec ) {
+    TCPhysConfig_t cfg; memset(&cfg,0,sizeof(cfg));
+    cfg.enabled     = (int)trap_Cvar_VariableValue( "g_tcphys_enable" );
+    cfg.max_active  = (int)trap_Cvar_VariableValue( "g_tcphys_maxActive" );
+    cfg.budget_ms   = (int)trap_Cvar_VariableValue( "g_tcphys_budgetMS" );
+    cfg.tick_hz     = (int)trap_Cvar_VariableValue( "g_tcphys_tickHz" );
+    cfg.sleep_lin_vel = trap_Cvar_VariableValue( "g_tcphys_sleepVel" );
+    cfg.sleep_time_ms = trap_Cvar_VariableValue( "g_tcphys_sleepTime" );
+    cfg.gravity     = trap_Cvar_VariableValue( "g_tcphys_gravity" );
+    cfg.bounce      = trap_Cvar_VariableValue( "g_tcphys_bounce" );
+    cfg.friction    = trap_Cvar_VariableValue( "g_tcphys_friction" );
+    cfg.lod_far     = trap_Cvar_VariableValue( "g_tcphys_lodFar" );
+    TC_Phys_SetConfig( &cfg );
+    float p[3] = {0,0,0};
+    if ( level.numConnectedClients > 0 ) { int c = level.sortedClients[0]; p[0]=level.clients[c].ps.origin[0]; p[1]=level.clients[c].ps.origin[1]; p[2]=level.clients[c].ps.origin[2]; }
+    TC_Physics_Step( msec, p );
+
+    /* Pull updated origins back into entities */
+    for ( int i = 0; i < level.num_entities; ++i ) {
+        gentity_t *e = &g_entities[i]; if ( !e->inuse ) continue; if ( !TC_EntPhysicsIsRegistered( e->s.number ) ) continue;
+        struct { float origin[3]; float velocity[3]; int asleep; } st;
+        if ( TC_EntPhysicsGetState( e->s.number, &st ) ) {
+            VectorCopy( st.origin, e->r.currentOrigin );
+            VectorCopy( st.origin, e->s.origin );
+            trap_LinkEntity( e );
+        }
+    }
+}
+#endif
@@ void G_RunFrame( int levelTime ) {
+#ifdef TC_PHYSICS
+    TC_ReadCvarsAndStep( msec );
+#endif
